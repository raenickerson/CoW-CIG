# # # # # # 
# Rae Nickerson
# Getting started with R
# Started 3.15.23
# Last updated 3.15.23
# # # # # # 

# This is a script that we are using in class to get started using R programming

x <- 2 # this is a comment

# Assinging Objects and noting bookmarks ####

# Functions and their arguments ####

?round # '?' before whatever you want to know more about

round(x = 465.5678, digits = 2)
round(465.5678, 2) # do the same thing because of how the round command is programmed

# Writing your own functions ####

function() {} # basic framework

add <- fucntion (x, y) {
  return (x + y) 
}

# this function takes as input two numbers, x and y, and it returns their sum

add(x = 3, y = 2) # to add parentheses, shift + (

z <- add(x = 3, y = 2)

prin_words <- function (x,y) {
  print(paste(x,y))
}

# Data Types ####

# character data
x <- "some text"
class(x)

x <- "1" # anything provided in quotes is a character
class(x)

# Integers

x <- 1
class(x)

x <- as.integer(1)
class(x)

# Logical (true of false data)
x <- TRUE
class(x)

y <- "TRUE"
class(x)

# Object types ####

## Vectors ####

# vectors are a collection of elements of the same data type:
x <- c(1, 2, 3, 4, 5)
class(x)
x
length(x)
# vectors can be any length, including 1

z <- ("A", "B", "C")
class(z)
length(z)

# cannot have different data types in one vector. If you do, it will assume everything
# is a character, whether or not that's true

new_vector <- c(1, FALSE)
class(new_vector) # in this case, because TRUE and FALSE are already coded in R
# as 0 and 1, R is assuming that you want a vector with numeric values. Only TRUE,
# FALSE, 0, and 1 can be considered logical data. 

logical_vector <- c(TRUE, FALSE, TRUE, TRUE)
sum(logical_vector) # this is SUPER useful, becuase can use the sum command in 
# big datasets to know how often SOMETHING happened, SUPER useful

# control + enter = how you run only highlighted code

## Factors ####

# how R stores categorical variables

years <- factor(c(2021, 2022, 2023, 2022))
years # gives us "levels" which are the unique labels for each vector, but under the hood, 
# each level is getting a number associated with it. 

# if want to change these to numbers, HAVE to add levels to as. commands
as.numeric(levels(years))

as.numeric(as.character(years)) # do this if you want to get a display of all your
# data shown in the way it's labeled. 

## Dataframes ####

df <- data.frame(
  numbers = c(1, 2, 3),
  letters = c("A", "B", "C"),
  colors = factor(c("blue", "red", "green"))
  )

str(df) # all have to be the same length, so need to add NA to anything that's uneven
df

### Subsetting ####

df$numbers # extracting just what you want
df$numbers[3] # take the third elemesnt of the numbers vector
df$letters[3] # take the third element of the letters vector

df [3,2] # how you call specific cells of the dataframe
df [3, ] # will give you the whole third row
df [ ,2] # returns column two

df[ , c(1,2)] # subsetting two columns at a time
df[ , 1:2] # from column 1 through column 2

# how to filter out or remove columns or rows
df[-1, ] # returns the dataframe without the first row
df[ ,-1] # does the same but with column
df[-c(1,2), ] # removes multiple at a time

## Matrix ####

# similar to a dataframe, but have to have all the same data types
mat <- matrix(nrow = 5, ncol = 5, data = 1:25)
mat # notice how it fills a columnn at a time
t(mat) # can transpose so fills one column at a time

mat[3,2] # returns values from specific cells

## Arrays ####

arr <- array(data = 1:24, dim = c(2, 4, 3)) # three-dimensional objects, super great if,
# lets say you have for example a raster over multiple years

arr[1, 4, 2] # = where 2 is the array number, row and column are the same

## conditional subsetting ####
# where is something located on your object?

# Logical conditions are anything that is an answer to operators like =, <, >, etc.
# == for equal to (1 equal sign is assign two things as the same, and don't want that)
# != for not equal to

# subset a dataframe based on a logical condition
df[df$colors == green, ] # returns all rows with a "green" value across all columns
df[df$numbers == 2, ]

df[df$colors == "green" & df$numbers == 3, ] # can set more than one condition.
# use "&" for and and "|" for or

## Lists ####

list1 <- list(1, 1:3, 1:10)

list2 <- list(1:10, c("dog", "cat", "mouse"), c(TRUE, FALSE))

list3 <- list(1:10, df)

list3 [[1]] #subsetting a list.
list3 [1] #not subsetting, just gave you the whole bucket

names(list3) <- c("vector", "dataframe") # naming elements in a list

list3$vector #subsetting by name

# when in doubt about what your grabbing, use class(xxx) to figure out what you 
#grabbed

# Control Structures ####

#if(condition) {
  #do something
#}

vec <- 1:10

if(vec == 3) {
  print(vec +1)
}

animal <- "dog"

if (animal == "cat") {
  print("I have a cat")
} else {
  print("I have a dog")
}

# Repeating Operations - Vectoization ####

vec <- 1:10

# if I want to add 1 to each value of this vector:
vec + 1

vec > 5 # both vectorized operations because dealing with each number individually

new_vec <- 2:11

vec + new_vec # another vectoized op where adding by element - element 
# 1+1, element 2+2, etc. Only works if they have the same number of elements. 
# otherwise, will start over and start back at the beginning of the shorter list.
# recycling the elements of the shorter vector. Will warn you, but will run, 
# which is tricky. NEVER IGNORE THIS WARNING MESSAGE!!
# whenever possible, us vectoization because for looping is MUCH slower

# For Loops ####
# Need when the next operation, depends on the previous one

for (i in 1:10) {
  print(i)
}

for (i in 1:10) {
  x <- i *2
  y <- x^2
  print(y)
}

res <- c()
for (i in 1:10) {
  x <- i *2
  y <- x^2
  res[i] <- (y)
} # assigning the y elements to the res vector, same as above but with a name. 
# could do this with a dataframe, too. Always have to make the empty container
# first. 

for(i in 1:10) {
  print("Hello!")
}
# nothing varies, so all going to get the same "Hello!"

for(i in 1:10) {
  print(paste("Hello!", i))
}
# marks each value with a "Hello!" without overwriting the original values (?)

# While Loops ####
# repeats the operation until the condition given is met

i <- 1
while(i < 6) {
  print(i)
  i <- i = 1
}

# change what i is assigned to, and notice will print only 1-5, until get to 6
# if changed the order of the print(i) an i <- i + 1 lines, whould get 2-6, because
# the order that operations are listed is the order they will be evaluated by 
# the loop. 

# Repeat Loops ####
# will repeat the function until the assigned break, and will keep doing through
# all possible values. 

i <- 1
repeat {
  print(i)
  i <- i + 1
  if (i >5) {
    break
  }
}

# one more for loop example

vec <- c(1, 10, 2, 9, 3, 8, 4, 7, 5, 6)

for (i in vec) {
  if (i < 5)
    print(i)
} else {
    next
}

# if want to remove something that doesn't meed the qualifications, add line
# } else {
# vec <- vec [-i]
# } # should only print the values that qualify. But be careful, because
# this will change the length of your vectors by the number of items removed. 
# and now as this loop continues to run, the interacting elements are now 
# different.

# How to trouble shoot a for-loop ####

# set i to the first value
# i <- vec[1]
# ignore the first line of the loop because just set to do manually
# run line two
# if (i < 5) {
# make sure getting the correct TRUE or FALSE

# Do this for each value in the vector, checking if correct. Learn here that 
# because i = 10, we lose our 6 (still don't understand why)

# The apply family functions ####

# functions in this family include apply, lapply, tapply, mapply, sapply, etc.
# only returns a vector, array, or list when given an array or matrix. That's it.
# lapply always returns a list

mat <- matrix(data = 1:25, ncol = 5, nrow = 5)

# if want to row-wise sum
apply(X = mat, MARGIN = 1, FUN = sum) # remember 1 for rows, 2 for columns in 
# MARGIN

# if want to write your own function:
apply(X = mat, MARGIN = 2, FUN = function(x) {
  ((x*2 + 5)^3)
})

# Turn into dataframe

df <- as.data.frame(mat)
df$V3 <- c("A", "B", "C", "D", "E")

apply(df, 1, sum) # will give you an error because can't sum with characters

apply(df, 1, function(x) {print(paste("Printing", x))}) # but this does work, 
# where returns 5 outputs where pasted the values with the "printing" title. 

# if want to only function some columns or rows:

apply(df[, c(1:2, 4:5)], 1, sum)

# example of lapply

l1 <- list(1:10, 2:20, 3:30)
lapply(X = l1, FUN = sum)

# can also customize the function
lapply(X = l1, FUN = function(x) {(x + 10) * 456})

# Using examples of repeated operations with Dragons Database ####

# example 1: ####
# what if we wanted to identify individuals who met 2 needs, let's say individuals
# who had both diet sampled, gps tracked, and had morphological data

#load DBI
library (DBI)

# connect to the database
dragons_db <- dbConnect(drv = RSQLite::SQLite(),
                        "../../../Course Material/Data/dragons/dragons.db")

# Load in relevant tables

diet <- dbGetQuery(conn = dragons_db,
                   "Select * From diet;")
gps <- dbGetQuery(conn = dragons_db,
                   "Select * From gps_data;")
morphometrics <- dbGetQuery(conn = dragons_db,
                   "Select * From morphometrics;")
dragons <- dbGetQuery(conn = dragons_db,
                   "Select * From dragons;")

head(dragons) # check that each has a unique ID so you can loop over

inds <- dragons$dragon_id
length(inds) # have 501 dragons total

inds[1] %in% morphometrics$dragon_id #asks if individual 1 is in the morphometrics
#table (although a vector here)
# can do this for all tables

# if doing gps data for example, and only need to know if the animal has at least
# one entry (oppossed to all gps entries) can do the following
inds[1] %in% unique(gps$dragon_id)
length(unique(gps$dragon_id)) # gives you the number of dragons with at least one 
# gps entry

# how to test how long a piece of code will take to run ####
# testing unique vs not unique
system.time({inds[1] %in% unique(gps$dragon_id)})
system.time({inds[1] %in% (gps$dragon_id)})

# Now, we want to creat the loop ####

res <- data.frame(dragon_id = NA,
                  has_morphometric = NA,
                  has_diet = NA,
                  has_gps = NA)

for (i in 1:legth(inds)) {
  
  res[i, ]$dragon_id <- inds[i]
  
  res[i, ]$has_morphometrics <- inds[i] %in% morphometrics$dragon_id
  res[i, ]$has_diet <- inds[i] %in% diet$dragon_id
  res[i, ]$has_gps <- inds[i] %in% unique(gps$dragon_id)
  }

# any opportunity you have to do pre-calculations outside of the loop, the better.
# so for example, unique(gps$dragon_id) is going to take longer to run than making
# a separate vector called "gps_ids" that only has unique values - 
# gps_ids <- unique(gps$dragon_id)

# Find individuals that have GPS and diet data ####

res$has_gps & res$has_diet # only returns TRUE for individuals with both
[res$has_gps & res$has_diet, ] # want to subset the rows, and keep all columns

nrow(res[res$has_gps & res$has_diet, ]) # to get the number of dragons
#or
length(res[res$has_gps & res$has_diet, ]$dragon_id)

# Example 2 - efficient ways to load in csv files in a loop ####

?list.files

files <- list.files("individual_telemetry_csv", pattern = ".csv", full.names = TRUE) # which is the
# name of the folder with all the different csv's, and takes out any other file types
# full.names = TRUE includes the path in the names

res <- data.frame()
for (i in 1:length(files)) {
  csv <- read.csv(files[i])
  res <- rbind(res, csv) #cbind is the command to do the same but with columns
}

# notice there are a LOT of points, and will need to delete points from before and
# after collar was deployed

# do the same thing using lapply ####
# usually, using lapply is SO MUCH FASTER

csv_list <- lapply(files, FUN = read.csv)

# need to get them all in the same dataframe

res3 <- do.call("rbind", csv_list)
nrow(res3)
nrow(res) # check that they are the same

# Example 3 - making plots for just the points you want ####

# values of the x axis
x <- 1:10

# slope coeff
m <- 0.5

# calculate values on the y-axis
y <- m*x

# Plot
plot(x = x, y = y, type = "l")

# say that we have a set of slopes
slopes <- seq(from = 0, to = 1, by = 0.01)

# simplify by doing all at once
for (m in 1: length(slopes)) {
  
  # calculate values on the y-axis
  y <- slopes[m] * x
  
  pdf(file = paste0("plots/plot_slope_", slopes[m], ".pdf", sep = ""), #could save as png, etc.
      height = 4, wiedth = 4) #0 after paste removes spaces
  # Plot
  plot(x = x, y = y, type = "l", ylim = c(0, 10),
       main = paste("Slope = ", slopes[m]))
  dev.off()
}

# can also do with lapply ####

plot_list <- lapply(X = slopes, FUN = function(m) {
  y <- m * x
  
  pdf(file = paste0("plots/plot_slope_", slopes[m], ".pdf", sep = ""), #could save as png, etc.
      height = 4, wiedth = 4, units = "in", res = 200) #0 after paste removes spaces
  # Plot
  plot(x = x, y = y, type = "l", ylim = c(0, 10),
       main = paste("Slope = ", slopes[m]))
  dev.off()
})

# to plot only certain plots from this list

plot(plot_list[[1]])

# Troubleshooting in R ####

# ?function # gives you functions in base R
# ??function # gives you functions in all packages

# all does the same thing:
dragons[, "dragon"][1]
dragons$dragon[1]
dragons[1, ]$dragon

# 'x' must be atomic error means that the object you've created is one dimensional
# if you don't want that, R was unable to decipher between your different objects
# usually means you added the list command where you didn't need it

species_list <- list(unique(dragons$species)) # won't work
sort(unique(dragons$species)) # will work because the sort command want a vector

# error - attempt to apply non-function - means likely that R thinks something is
# a function that you didn't mean to be a function - usually need more parentheses
# or you forgot something between your objects (for example, a math command)

# two ways of doing the same thing for a dataframe
dat[[2]]
dat[, 2]

# NA associated errors - R will always return NA even if there are only some NAs

# if want to remove na's, can add na.rm = TRUE. Otherwise have to code as something
# else

# troubleshooting a vector ####

my_list <- list(10, 74687, TRUE, "A", FALSE, 65, "hello")

for (i in 1:length(my_list)) {
  print(my_list[[i]] + 10)
}

# this won't work, where do we start troubleshooting?
# first, step i = to the first value, and run row by row
# another trick - go into your environment and see what the latest value was
# before the loop failed. Then put that number in, and re-run to find the error

# always want to set i = to a number. 


# Dependency Management ####

# because packages are saved in your files assocaited with an R project, 
# you can save different versions of different packages for different projects
# so that your code doesn't break down

# to find out where your packages are
.libpaths()

# to us renv (to do this) have to be using an R project (click that option when
# creating the project)

install.packages("renv") # but put in console so not redownloading every time
renv::init() # also only do this in the console









































































  













